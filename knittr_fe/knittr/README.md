# Knittr
#### Video Demo:  [LINK](https://youtu.be/pPvfbsCB47Y)
#### Description:
Knittr is a web app that allows users to write and share knitting patterns, as well as do projects based on patterns uploaded by other users. The projects they start have the ability to keep track of their current progress down to the row, and write and stores notes. When a project is completed, the user can choose to upload any photos they have taken of their work. For more detailed notes on the functioning of the UI, see the USER_DIRECTIONS.md document.

I had this general idea for a project for a while, as it solves certain problems of mine. Like many people who knit, I have a bad habit of putting down a project for 6 months only to pick it back up and have no idea where I am. This keeps track of that, and allows you to bring projects on the go without carrying any extraneous equipment besides that yarn and needles. Users can write their own patterns of find existing ones to follow.

I have too many file to go in depth into what each one does, so I will give an overview of the project structure, as well as go from front to back for a select component at hte end of the readme. My decision to use Postgres, Java and Spring Boot for the backend was primarily because I have used them before in a bootcamp I completed.

I had considered using Vue on the frontend for the same reason, but I decided to learn React instead. In the future, I may want to turn this into a mobile app using React Native, and although it's not easy, it still seemed smarter in the long run as I will have the logic laid out already. I liked the utility of Bootstrap shown during the course, and figured that would be a useful tool for creating my frontend as well. I also used FontAwesome icons, and utilized Cloudinary for image hosting, while keeping links and app-specific metadata for the images in my backend database.

I created a database in PostgreSQL to store all my users, patterns, and projects in. I also had a number of supporting and relational tables, and wound up creating a "variant" table that stored the combinations of patterns, yarns, and sizes that were needed to relate the instructions to the patterns and projects. These instructions were broken down first into steps, which were made up of many rows. I struggled with how best to store these rows, and toyed with the idea of saving them as arrays within the steps table, but decided not to in order to pass 1st form.

On top of this I used the Java and Spring Boot framework to build a Model-View-Controller based REST API to serve as the backend. I built CRUD controller as needed for my various models, and a service layer to handle "business" logic as needed, and handed everything to a JDBC DAO layer to make database queries. I followed along with instructions to use Springboot security with a package called jwtoken.io for handling authorization.

Within my React front end I created various "service" modules that separated all of the API calls (I used axios) based on what model they interacted with. For some calls that needed to be made nested components I also created some custom hooks to handle the asynchronous calls. My overall structure was based in part on the standard organization used by the latest release of React-Router, such as 2 layout files for pages with many common features, and about a dozen page files within their own directory. I also created about 35 unique components that are used within the various layouts and pages.

I included a base.css file that established overall color schemes, the styling of buttons, etc. as well as whatever was needed to override default Bootstrap styles. I also created some specific CSS module files that I bundled with pages/layouts/components when they had their own unique considerations. There are also separate files to establish the routing for the site, and a file (apiResponseTypes.ts in the helpers folder) that established interfaces that match the models from my backend to be used by typescript throughout the application.

#### Sample component structure

For an example of front to back structure, we'll look at the notesSection component. The notess section is used my project layout (though hidden until selected on my small screens). The .tsx file starts with the import statements (including an import of the .css file in the same folder). It then exports the jsx component function that contains all the logic and rendering. I used React's useState to store a newNote (the string entered) and a boolean value of whether to show the textarea element that a user would type said note into.

Next I import allNotes and postNote from my custom useNotes hook. That file creates a state to store a list of all notes associated with the project, then useEffect to import them. The postNote function takes in a string (the note body) and posts it to the API on the backend. Then it sets the allNotes state to all previously existing notes (using the pread operator) and the the newly returned note.

Back in the component file, next I define the subnit behavior for the new note form, and finally lay out the 'HTML' that will make up the DOM for the notes section using jsx syntax.

When the useNotes hook is called, it calls the notesService.ts file in the services folder, and either, initiating either a GET or POST request depending on which function is called. The requests are handled by the axios package, which is configured in the axiosConfig.ts file in the same folder. The axiosConfig sets up the base URL ro make API calls to, as well as adds interceptors to make sure that the JWT is included in the request headers if logged in.

Over on the backend, the requests are received by the NoteController Java file. Depending on what request is made (a POST to '/notes' or a GET to '/projects/{id}/notes') the request is sent to the appropriate method via Spring Boot. Regardless, the controller calls methods from NoteService. In the service layer, a function is called to check that the logged in user is the same as the user associated with the specific project, otherwise it returns a status 403 FORBIDDEN error. If it is the correct user, then the DAO layer is called.

Springboot uses dependency injection to utilize the appropriate JDBC classes for the interfaces defined. Within the JDBC's functions, a string representing a SQL query is defined in such a way as the prevent SQL injection attacks, which is then passed to a JdbcTemplate object courtesy of Spring. Any needed variables (e.g. userId, note body) are passed along with the SQL query. If the query is successful, a mapping function creates a new Note instance from the returned values, and returns that up the chain to eventually be passed to the client. If an error is encountered, a custom Excpetion is thrown with a specific message, which is bubbled up as appropriate to the upper layers.
